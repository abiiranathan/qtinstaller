package qtinstaller

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

const installerLogo = "installerLogo"

// Config stores the properties to configure the installer.
type Config struct {
	DisplayName   string // Application display name
	Description   string // Application description
	Version       string // Software version
	ReleaseDate   string // Release date e.g 2022-12-12, default, current date
	PkgName       string // Globally unique identifier e.g com.domain.appname
	Executable    string // Path to the main Qt Executable generated by the build process.
	InstallerName string // Output installer name

	LicenceName string // Name of the licence for your software.
	LicencePath string // Path to the licence file. default licence.txt in the working dir
	Publisher   string // company publishing the software

	// Filename for a logo in PNG format used as QWizard::LogoPixmap.
	Logo string

	// Filename for a custom installer icon.
	//The actual file is looked up by attaching a '.icns' (macOS), '.ico' (Windows) suffix.
	//No functionality on Unix.
	InstallerApplicationIcon string
}

// Directories for a simple offline installer.
// Config, Data and Meta.
type installerDirs struct {
	Config string // config directory
	Data   string // packages/<pkg_name>/data
	Meta   string // packages/<pkg_name>/meta
}

// Default configuration.
// Sets the default version, date, installer name, licence name and
// licencePath.
var defaultConfig = Config{
	Version:       "0.1.0-1",
	ReleaseDate:   time.Now().Format("2006-01-02"),
	InstallerName: "Installer.exe",
	LicenceName:   "MIT License Agreement",
	LicencePath:   "licence.txt",
}

// Writes the default .env file in the same directory.
// Returns an error if os.WriteFile fails.
func GenerateConfigFile() error {
	text := fmt.Sprintf(configTextTemplate,
		DisplayName,
		Publisher,
		Description,
		ReleaseDate,
		Version,
		PackageName,
		Executable,
		InstallerName,
		LicenceName,
		LicenceFile,
		Logo,
		InstallerApplicationIcon,
	)
	return os.WriteFile(".env", []byte(text), 0640)
}

// Returns the expected default directories for the
// Qt installer framework.
// The config, packages(having data and meta subdirectories)
func GetInstallerDirs(config *Config) *installerDirs {
	dirs := &installerDirs{
		Config: filepath.Join("./config"),
		Meta:   filepath.Join("./packages", config.PkgName, "meta"),
		Data:   filepath.Join("./packages", config.PkgName, "data"),
	}

	dirAbsPaths(dirs)
	return dirs
}

// Sets absolute paths for all dirs.
func dirAbsPaths(dirs *installerDirs) {
	configDir, _ := filepath.Abs(dirs.Config)
	dirs.Config = configDir

	MetaDir, _ := filepath.Abs(dirs.Meta)
	dirs.Meta = MetaDir

	DataDir, _ := filepath.Abs(dirs.Data)
	dirs.Data = DataDir
}

// Generate data from config and dirs and write this data into the appropriate files.
func WriteFiles(config *Config, dirs *installerDirs) error {
	// get InstallerWindowIcon from logo
	baseDir, logoName := filepath.Split(config.Logo)
	installLogoPath := filepath.Join(baseDir, installerLogo+filepath.Ext(logoName))

	// write config/config.xml
	err := os.WriteFile(
		filepath.Join(dirs.Config, "config.xml"),
		[]byte(fmt.Sprintf(configXMLTemplate,
			config.DisplayName,              // name
			config.Version,                  // version
			config.DisplayName,              // title
			config.Publisher,                // publisher
			config.DisplayName,              // StartMenuDir. Name of the default program group for the product in the Windows Start menu
			installLogoPath,                 //InstallerWindowIcon
			config.InstallerApplicationIcon, // InstallerApplicationIcon
			config.Logo,                     // Logo
			config.DisplayName,              // TargetDir. Default target directory for installation.
		)),
		0640,
	)

	if err != nil {
		return err
	}

	// copy config images described in the config.xml above
	err = copyFileToDir(config.Logo, dirs.Config)
	if err != nil {
		return err
	}

	// duplicate logo and save copy as installerlogo
	err = copyFileToDir(config.Logo, dirs.Config, installLogoPath)
	if err != nil {
		return err
	}

	// copy application icon(.ico)
	err = copyFileToDir(config.InstallerApplicationIcon, dirs.Config)
	if err != nil {
		return err
	}

	// copy executable
	err = copyFileToDir(config.Executable, dirs.Data)
	if err != nil {
		return err
	}

	// copy licence
	err = copyFileToDir(config.LicencePath, dirs.Meta)
	if err != nil {
		return err
	}

	// copy package.xml
	err = os.WriteFile(
		filepath.Join(dirs.Meta, "package.xml"),
		[]byte(fmt.Sprintf(
			packageXMLTemplate,
			config.DisplayName,
			config.Description,
			config.Version,
			config.ReleaseDate,
			config.LicenceName,
			config.LicencePath,
		)),
		0640,
	)

	if err != nil {
		return err
	}

	// Write the installscript.qs
	baseName := filepath.Base(config.Executable)

	// Path to the windows StartMenu link
	linkName := strings.TrimSuffix(baseName, filepath.Ext(baseName)) + ".lnk"

	return os.WriteFile(
		filepath.Join(dirs.Meta, "installscript.qs"),
		[]byte(fmt.Sprintf(
			installScriptTmpl,
			baseName, linkName, baseName,
			baseName, linkName, baseName,
		)),
		0640,
	)

}

// copyFileToDir copies the srcFile to a dstDir directory.
// If the destination dir does not exit, it's created.
// If newName is provided(withthe file extension, it's used instead.)
func copyFileToDir(srcFile, dstDir string, newName ...string) error {
	_, file := filepath.Split(srcFile)

	err := os.MkdirAll(dstDir, 0755)
	if err != nil {
		return err
	}

	data, err := os.ReadFile(srcFile)
	if err != nil {
		return err
	}

	// Use filepath.Join to create the destination path.
	dstPath := filepath.Join(dstDir, file)
	if len(newName) > 0 {
		dstPath = filepath.Join(dstDir, filepath.Base(newName[0]))
	}
	return os.WriteFile(dstPath, data, 0644)
}

// Reads key from environment variables.
// If the value returned is not empty, the param is updated.
// Otherwise it panics if this key was required.
func setConfigVar(param *string, key string, required bool) {
	value := os.Getenv(key)
	if value == "" {
		if required {
			log.Fatalf("evironment variable %s is required.\n", key)
		}
	} else {
		*param = value
	}
}

// Returns a new config file.
func NewConfig() *Config {
	config := &defaultConfig

	// required env variables
	setConfigVar(&config.DisplayName, DisplayName, true)
	setConfigVar(&config.Description, Description, true)
	setConfigVar(&config.PkgName, PackageName, true)
	setConfigVar(&config.Executable, Executable, true)
	setConfigVar(&config.LicenceName, LicenceName, true)
	setConfigVar(&config.LicencePath, LicenceFile, true)
	setConfigVar(&config.Publisher, Publisher, true)
	setConfigVar(&config.InstallerApplicationIcon, InstallerApplicationIcon, true)
	setConfigVar(&config.Logo, Logo, true)

	// Optional env variables
	setConfigVar(&config.ReleaseDate, ReleaseDate, false)
	setConfigVar(&config.Version, Version, false)
	setConfigVar(&config.InstallerName, InstallerName, false)
	return config
}

// Creates the directories specified in dirs.
// The config, data and meta directories.
// Old directories are deleted if they exist.
func CreateDirectoryStructure(dirs *installerDirs) error {
	// Remove old directories.
	os.RemoveAll(dirs.Config)
	os.RemoveAll(dirs.Meta)
	os.RemoveAll(dirs.Data)

	// Create new directories.
	if err := os.MkdirAll(dirs.Config, 0640); err != nil {
		return err
	}

	if err := os.MkdirAll(dirs.Meta, 0640); err != nil {
		return err
	}
	return os.MkdirAll(dirs.Data, 0640)
}

func panicIfNotFileExists(path ...string) {
	for _, f := range path {
		if _, err := os.Stat(f); err != nil {
			log.Fatalf("File not found: %s\n", f)
		}
	}
}

func AssertFilesExist(config *Config) {
	panicIfNotFileExists(
		config.Executable,
		config.LicencePath,
		config.InstallerApplicationIcon,
		config.Logo,
	)
}

func GetQtBinaries() (windeployqt string, binarycreator string, err error) {
	// Make sure windeployqt is in PATH
	windqt, err := exec.LookPath("windeployqt.exe")
	if err != nil {
		return "", "", fmt.Errorf("windeployqt.exe is not installed or not in PATH. Install it and try again")
	}

	// Make sure binarycreator is in PATH
	binCreator, err := exec.LookPath("binarycreator.exe")
	if err != nil {
		return "", "", fmt.Errorf("binarycreator.exe is not installed or not in PATH. Install it and try again")
	}

	return windqt, binCreator, nil
}
